
## 出発点と目標

プログラミング言語の仕様・設計及びソースコード中で可能なオブジェクト(後節で定義)を現実世界、とりわけ代数学の体系に完全に一致されるよう、プログラミングパラダイムにおいて整理・体系化することを目標とする。整理・体系化することにより明解になり、プログラミング言語の仕様・設計及びソースコードがより分かりやすくなり、したがってバグや罠を減らす効果をもたらす。

関数型及びオブジェクト指向を議論の出発点とする。
現実世界とプログラムを対応付け理解しやすくし、またプログラミング言語の仕様・設計を明解にするという目標から考えると、「実世界を理解しやすくすることと、コンピュータ上への実装に関して実質的な基盤を与えることである。」とランボーにより定義される(ランボー et.al., p.25)オブジェクトを取り扱うオブジェクト指向を論考の基盤の一つとすることは妥当であると考えられる。
関数型は数学的な関数を基礎としてカリーハワード同型対応や圏論をはじめ代数学の様々な理論を用いて体系化されているが、本発表における計算代数系はこれをさらに進めて、代数的構造を扱う代数学全体を用いて考察し直すことにより、より見通しよくすることができると信じる。

## オブジェクト

プログラム上における値そのものや、それらの値、そしてその値に対する演算などの処理を束ねたデータである()。概念や抽象あるいは対象となる問題に対して明確な境界と意味を持つ何ものかであり(ランボー et.al., p.25)、コンピュータによる計算の対象となる実体である(オージス総研1999)と説明できる。

## 代数 - Aljebraics(Algebraic Models)

プログラム中で可能なオブジェクトの記号表現として、代数の概念を提唱する。代数とは、常数、定数、変数、関数を統合したものであり、これらの総称である。また、プログラム中で可能なオブジェクトの直接的な表現はリテラルである。

### 型体系 - The Type System

型(データ型)はそれ自身オブジェクトであり、またオブジェクトを定義する集合であると見做すことができる()。データ型は包含的派生型による型ツリーを構築する。

型は集合であるので、包含的派生型は部分集合に対応付けることができる。

型は集合であるので集合演算が可能であり、演算結果を新たな型として定義したり、また利用することができる。

集合たる型について考えることは不正なデータという重要なバグの一群を説明するのに役立つ()。型理論は圏論を用いて考察されるが、本発表では主題として取りあげないので、型体系に関する論考は省く。



## 関数

関数は、データ型からデータ型への写像であり、具体的には計算や処理の定義である。独立代数を引数、従属代数を返り値とする。

引数及び返り値はいついかなる時でも一つである。複数の代数を受け渡しする必要がある場合はタプル型を、受け渡しする代数がない場合は Void 型を用いる。これは、写像は一対一対応であることと対応する。また引数の型は定義域、返り値の型は値域と対応する。

ここで論じる関数は、数学における関数と同じように合成することが可能であるものとする。

☆可換性

```
fun1().fun2()
```

と

```
fun2().fun1()
```

が等しいという命題は必ずしも成り立たない

例えば、次例のように

1. 参照透過性をもつ
1. 片方の引数・返り値ともう一方の返り値・引数が対応する(またはvoidである)
1. 処理内容が双対的である

※参照透過性と

を満たす場合であれば可換であるし、

例　可換な例

```
int->int fun1(x):= x+1
int->int fun2(x):= x-1
```

次例のようにそうでない場合は可換ではない

例　可換でない例

```
fun1(x):=x+1
fun2(x):=x*2
```
参照透明性は、関数外で定義された外部変数の変更と、外部ファイルへの書き混みアクセスは、その後の計算環境を変更してしまうという点から、関数を評価する順序を変更した場合に結果の同一であることを保障できないため、この制約は妥当である。
また、引数・返り値の対応関係は、関数間で値の受け渡しをすることが可能か否かに、また双対性は関数が互いに対称的で関数の意味が全体として等しいかどうかに関係する。


☆分配律

本節では関数が分配律を満たすと考えられることについて述べる。

関数における分配律について述べる前に、説明のための演算子を1つ導入する。
その演算子は`:>`で、式と式を並列し結合した式とする(並列実行はランタイムにより同期的になることも非同期になることもあるがここでの議論には関わらないので未定義とする)。

```
fun1()..fun2()
      ..fun3()
```

というカスケード構文より

```
fun1().(fun2():>fun3())
```

は

```
fun1().fun2()
fun1().fun3()
```

すなわち

```
(fun1().fun2()):>(fun1().fun3())
```
と等しい

従って分配律を満たす

### 関数合成

この言語においては、いかなる関数も任意に合成することができ、関数を引数に渡すこと、及び関数チェーンにより実装できる。数学(代数学)の関数合成と同じである。関数チェーンは、代数学における合成演算子(∘)がドット(`.`)になっただけである。

f().g()

関数チェーンを行った場合、返り値が次の第一引数となる。この返り値と第一引数の型が違う場合(キャストが指定されている場合を除く)には、普通の代入と同様にエラーが吐かれる。関数の引数渡しと関数チェーンは次のように対応する。

- 引数渡し: 　`f (g (x))`
- 関数チェーン: 　`g () . f ()`

## 代数的データ構造

代数的データ構造は則ち集合である.